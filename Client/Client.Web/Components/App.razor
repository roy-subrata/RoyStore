<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <link rel="stylesheet" href="_content/Client.Shared/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="_content/Client.Shared/app.css" />
    <link href="_content/Client.Shared/css/output.css" rel="stylesheet" />
    <link rel="stylesheet" href="Client.Web.styles.css" />
    <link rel="icon" type="image/png" href="_content/Client.Shared/favicon.png" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href="@Assets["_content/MudBlazor/MudBlazor.min.css"]" rel="stylesheet" />
    <script src="@Assets["_content/MudBlazor/MudBlazor.min.js"]"></script>
    <HeadOutlet @rendermode="InteractiveServer" />
</head>

<body>
    <Routes @rendermode="InteractiveServer" />
    <script src="_framework/blazor.web.js"></script>


    @* <script>
        window.__autocompletePopovers = window.__autocompletePopovers || {};

        window.attachAutocompleteScroll = (inputId, dotnetHelper) => {
            const input = document.getElementById(inputId);
            if (!input) return;

            // find visible popovers
            const popovers = Array.from(document.querySelectorAll('.mud-popover'))
                .filter(p => p.offsetParent !== null); // visible ones

            if (popovers.length === 0) return;

            // pick the popover closest to the input (works even if multiple popovers exist)
            const inputRect = input.getBoundingClientRect();
            let chosen = null;
            let minDist = Infinity;
            for (const p of popovers) {
                const r = p.getBoundingClientRect();
                const dist = Math.abs(r.top - inputRect.bottom);
                if (dist < minDist) { minDist = dist; chosen = p; }
            }
            if (!chosen) return;

            // remove any previous handler on that element
            if (chosen.__autocompleteScrollHandler)
                chosen.removeEventListener('scroll', chosen.__autocompleteScrollHandler);

            const handler = () => {
                if (chosen.scrollTop + chosen.clientHeight >= chosen.scrollHeight - 5) {
                    dotnetHelper.invokeMethodAsync('OnScrollEnd').catch(() => { });
                }
            };

            chosen.__autocompleteScrollHandler = handler;
            chosen.addEventListener('scroll', handler);

            // store mapping so we can detach later
            window.__autocompletePopovers[inputId] = chosen;
        };

        window.detachAutocompleteScroll = (inputId) => {
            const p = window.__autocompletePopovers && window.__autocompletePopovers[inputId];
            if (!p) return;
            if (p.__autocompleteScrollHandler) {
                p.removeEventListener('scroll', p.__autocompleteScrollHandler);
                delete p.__autocompleteScrollHandler;
            }
            if (window.__autocompletePopovers)
                delete window.__autocompletePopovers[inputId];
        };
    </script> *@

</body>

</html>
